#+TITLE:     CL Spacetime 
#+AUTHOR:    William Clifford
#+EMAIL:     wobh@yahoo.com
#+DATE:      2014-11-08 Sat
#+DESCRIPTION: Simple spacetime physics calculator in Common Lisp
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:6 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

* Introduction

I've previously modeled spacetime as a push-down stack of "herenow"
states. That's seemed clever at first. I like the idea of the
accumulator and the general idea of spacetime as emergent
property. However, here I'd like to explore some basic physics to
understand it better and seek out another clever idea about spacetime.

* COMMENT Properties 						   :noexport:

#+PROPERTY: header-args  :mkdirp yes :noweb yes :padline no
#+PROPERTY: header-args+ :tangle-mode (identity #o700)

#+BEGIN_SRC elisp :results silent
  (defun tangle-done (file &optional dir)
    (unless dir
      (setq dir (or (file-name-directory file) ".")))
    (when (org-entry-is-done-p)
        (concat (file-name-as-directory dir) file)))
  
  (defun noweb-done (ref)
    (when (org-entry-is-done-p)
      ref))
#+END_SRC

* Celerity 

Speed is a ratio of distance to duration. As a scalar value distance
may be any positive rational number and time may be any non-zero
positive number. It can be vectorized in one dimension by allowing
negative values, such that however zero is still not permitted for
durations. 

For the sake of simplicity I'm going to ignore the common conventions
and measures of length and time and just use integer values for these
things. I'm aware that there are actual formal systems that physicists
use that do this (e.g. "Planck Units") but I'm not committing myself
to any of them just yet. For one thing I don't know enough about
them. However it seems reasonable for now to just assume a minimum
distance and duration and work with that.

We can implement these ideas about space and time in Common Lisp with
types.

#+BEGIN_SRC lisp
  (deftype distance ()
    "A distance may be any positive integer."
    `(integer 0))
  
  (deftype duration ()
    "A duration may be any non-zero positive integer."
    `(integer (0)))
#+END_SRC

There's a few rules here that suggest another important constraint.

- Any motion over a distance must take a non-zero amount of time.
- It takes a minimum of one time unit to move one space unit.

Therefore:

- the maximum speed to travel n units of space is n/n, or 1.

We need no more words than this to implement it.

#+BEGIN_SRC lisp
  (deftype speed ()
    "A speed must be a rational number between 0 and 1."
    `(rational 0 1))
#+END_SRC

** Questions [0/3]

Some things I'm pondering, intentionally in the most naive way, on the
way to thinking about relative motion.

*** TODO What's the maximum amount of time it takes to move one space unit?

Possibilities:

- infinity
- if an object hasn't moved after time =MAXTIME= it won't ever
- if an object hasn't moved before time =MAXTIME= it must

*** TODO When does something move?

An object moving at speed =1/t= where =t > 1= seems to have a choice
among =t= time units in order to make it's move.

Possibilities

- you can't observe it having moved before it did, so it moves on the
  last tick of the duration.
- randomly moves, and speed for any larger multiple of the minimum
  duration must be an average or other reduction.

**** TODO How does it choose?

**** TODO What could influence that choice?

** Code review

For anything that you define a type for, it's usually a good idea to
define a true/false test for that type and use the test for the type
definition. These tests are called "predicates" and traditionally
named with "p" at the end of the type name, or "-p" if the type name
is multiple words.

#+NAME: celerity.lisp
#+HEADER: tangle (tangle-done "celerity.lisp" "./src")
#+BEGIN_SRC lisp
  (defun distancep (d)
    "A distance must be a positive integer."
    (typep d '(integer 0)))
  
  (deftype distance ()
    "Distance definition"
    `(satisfies distancep))
  
  (defun durationp (d)
    "A duration must be a non-zero positive integer."
    (typep d '(integer (0))))
  
  (deftype duration ()
    "Duration definition"
    `(satisfies durationp))
  
  (defun speedp (s)
    "A speed must be a rational number between 0 and 1."
    (typep s '(rational 0 1)))
  
  (deftype speed ()
    "Speed definition"
    `(satisfies speedp))
#+END_SRC
* Circular

Our first notion of direction emerges from a primal experience of
facing and turning. A whole turn brings one around to the same
orientation one started in. 

Turning is constrained by dimensionality. For beings that are the
smallest size possible, the world can only offer some set of axes to
face it. In one dimension, the smallest beings only have to turn
twice, flipping diametrically, to return to the same
orientation. The 1d being has no use for "right" or "left" only
"forward" and "backward". It only takes one action to do it,
"reverse". 

The smallest 2d being has a new orthagonality it can look down. Order
and direction matter. After one turn, only the inverse can bring it
back. To make a full turn without changing direction, it must make 4
quarter turns. In three-dimensions there are 3 axes and 6 facings, the
smallest being can look down.

Valid directions for any axis could be represented by 1, or -1. Multi-
dimensional directions can be implemented as one of the lisp sequence
types containing only directions. Using types again a list of
directions could be implemented so:

#+BEGIN_SRC lisp
  (defun directionp (dir)
    "A valid direction must be a sequence containing either 1 or -1."
    (labels ((dirp (dlist) (every dlist (lambda (d) (= 1 (abs d))))))
      (etypecase dir
        (list (dirp dir))
        (vector (dirp (coerce 'list dir))))))
  
  (deftype direction ()
    "Direction definition"
    `(satisfies directionp))
#+END_SRC


Here are some helpful methods. I'm not interested in formally defining
a direction class right now, so I'll have to do some internal type
checking.
  
#+BEGIN_SRC lisp
  (defmethod reverse ((dir sequence))
    "Return the reverse direction"
    (check-type dir direction "a direction")
    (labels ((flip (d) (* -1 d)))
      (etypecase dir
        (list (mapcar #'flip dir))
        (vector (map 'vector #'flip dir)))))
  
  (defmethod combine ((d1 sequence) (d2 sequence))
    "Combine directions"
    (dolist (d (list d1 d2))
      (check-type d 'direction "a direction"))
    (let (longer shorter)
      (if (< (length d1) (length d2))
          (setf longer d1 shorter d2)
          (setf longer d2 shorter d1))
      (map-into 'list longer shorter)))
#+END_SRC

Larger beings turn in rotations to face what seems like an arbitrary
number of directions. Although it's probably similiar to the above,
I'm not sure how to implement the multi-dimensional aspect described
above, but for any given plane I think the implementation of angle
below will serve.

#+NAME: circular.lisp
#+HEADER: :tangle (tangle-done "circular.lisp" "./src")
#+BEGIN_SRC lisp
  (defun anglep (n)
    "Test if n is a valid angle."
    (typep n '(rational 0 1)))
  
  (deftype angle ()
    "A valid angle is a Rational number between 0 and 1."
    `(satisfies anglep))
  
  (defun angle= (a1 a2)
    "Compare two angles."
    (check-type a1 'angle)
    (check-type a2 'angle)
    (or (= a1 a2)
        (and (= a1 0) (= a2 1))
        (and (= a1 1) (= a2 0))))
#+END_SRC
*** TODO reverse and combine angles
http://hyperphysics.phy-astr.gsu.edu/hbase/vect.html#vec4
** Velocity

Putting together the idea of speed with the idea of direction I find
the idea of velocity. Where speed is a scalar value with only a
magnitude, velocity is a vector with magnitude and direction. We can
encode this in a variety of ways.

For better or worse, Common Lisp uses the word "vector" for a
one-dimensional array. We can redefine it in a package, but we can
probably just as easily use it for our purposes. Although we can't
subclass or modify Common Lisp built-in classes, we can add all the
methods we want to them. For vectors, I'm starting with these two.

#+BEGIN_SRC lisp
  (defmethod basis ((v vector) i)
    "Accessor for vector values."
    (aref v i))
  
  (defmethod bases ((v vector))
    "List values in vector."
    (coerce v 'list))
#+END_SRC

We're ready to start thinking about the different kinds of spaces
these vectors can describe movement through.

*** Cartesianesque

Cartesian space is likely the most familiar. Some number of orthagonal
axes, intersecting at an origin point, zero, define the space. For
reasons I hope will be clear bit later, I won't implement Cartesian
vectors in quite the way I learned them in school. Here's how to
understand the Cartesianesque vectors I'm using.

Each =basis= of the vector is a rational number, the absolute value of
represents a speed along a particular axis. The positive or negative
value of the =basis= represents the direction along the axis.

I will not formally define any mappings of the vector indices to
particular axes. However, if it seems appropriate to use a Common Lisp
array to represent a space, the vector axis will follow (y, x) order
for 2d arrays, and (z, y, x) order for arrays of 3 dimensions. The
reason for this is that CL arrays have a default =row-major-index=
ordering and this way applying the vector to change a position in the
array will naturally align with =row-major-index= order of the array
subscripts.

#+BEGIN_SRC lisp
  (defmethod c-direction ((v1 vector))
    "Direction of cartesian velocity vector"
    (labels ((dir (d) (ecase d (plusp 1) (minusp -1))))
      (map 'list #'dir v1)))
  
  (defun c-velocity-p (v)
    "Test if argument could be a c-velocity vector."
    (every (mapcar #'abs (bases v)) 'speedp)
    (every (direction v) 'directionp))
  
  (deftype c-velocity ()
    "Define c-velocity vector"
    `(satisfies c-velocity-p))
  
  (defun c-velocity (&rest bases)
    "Create a Cartesian velocity vector."
    (let ((cv (make-array (length bases)
                          :element-type 'rational
                          :fill-pointer t
                          :initial-contents bases)))
      (or (check-type cv 'c-velocity-p) cv)))
  
  ;;; TODO come up with a better name than "c-velocity"
#+END_SRC

There's a problem. It's an old problem, and fortunately a solved
problem, but I've set myself up for it, and only half on purpose. You
see, I knew this was coming, and I told myself I would think about it,
but I forgot to do so. In any case I'll have to address it.

**** The problem

I said I was going to define a fundamental minimum distance unit
of 1. But math has thwarted me. You see, that works fine for distances
in a single dimension, but as soon as I added even one more, I run up
against an ancient discovery and confoundment of incommeasurable
things. The diagonal of a square cannot be rationally compared to a
side.

#+BEGIN_SRC lisp
  (defmethod c-distance ((v1 vector))
    "Distance of cartesian velocity vector"
    (labels ((square (n) (expt n 2)))
      (sqrt (reduce #'+ (map 'list #'square (bases v1))))))
#+END_SRC

What does this mean for our velocities? What does this mean for our
minimum length?

The solution that has come to us over the millenia is to invent
"irrational" numbers. This is a good solution, but we've been faced
with a practical problem of expressing their values in a convenient
way. The popular solution is the decimal expansion which carries out a
rationalization for some degree of precision and then stop, supposing
that the loss of precision after that point is probably acceptable.

| pwr | 1 |         2 |         3 |         4 |         5 |         6 |
|-----+---+-----------+-----------+-----------+-----------+-----------|
| 1/1 | 1 |         2 |         3 |         4 |         5 |         6 |
| 1/2 | 1 | 1.4142136 | 1.7320508 |           | 2.2360680 | 2.4494897 |
| 1/3 | 1 | 1.2599210 | 1.4422496 |           | 1.7099759 | 1.8171206 |
| 2/3 | 1 | 1.5874011 | 2.0800838 | 2.5198421 | 2.9240177 | 3.3019272 |
| 1/4 | 1 | 1.1892071 | 1.3160740 |           | 1.4953488 | 1.5650846 |
| 3/4 | 1 | 1.6817928 | 2.2795071 | 2.8284271 | 3.3437015 | 3.8336586 |
| 1/5 | 1 | 1.1486984 | 1.2457309 | 1.3195079 | 1.3797297 | 1.4309691 |
| 2/5 | 1 | 1.3195079 | 1.5518456 |           | 1.9036539 | 2.0476725 |
| 3/5 | 1 | 1.5157166 | 1.9331820 | 2.2973967 | 2.6265278 | 2.9301561 |
| 4/5 | 1 | 1.7411011 | 2.4082247 | 3.0314331 | 3.6238983 | 4.1929627 |
| 1/6 | 1 | 1.1224620 | 1.2009370 | 1.2599210 | 1.3076605 | 1.3480062 |
| 5/6 | 1 | 1.7817974 | 2.4980495 | 3.1748021 | 3.8236225 | 4.4510183 |
| 1/7 | 1 | 1.1040895 | 1.1699308 | 1.2190137 | 1.2584990 | 1.2917083 |
| 2/7 | 1 | 1.2190137 | 1.3687381 |           | 1.5838196 | 1.6685104 |
| 3/7 | 1 | 1.3459002 | 1.6013289 | 1.8114473 | 1.9932353 | 2.1552289 |
| 4/7 | 1 | 1.4859943 | 1.8734440 | 2.2081790 | 2.5084846 | 2.7839271 |
| 5/7 | 1 | 1.6406707 | 2.1917999 | 2.6918004 | 3.1569252 | 3.5960218 |
| 6/7 | 1 | 1.8114473 | 2.5642542 | 3.2813414 | 3.9729870 | 4.6450114 |
#+TBLFM: @2$2..@>$>=@1^($1)

I find this state of affairs somewhat unsatisfying. The integers are
all founded upon 1. The rationals founded upon the prime integers. But
these "irrational" numbers are their own unique numerism, if you will,
as foundational as 1 is to the integers, in their ability to produce
unique values. (

Presently, I have only enough math chops to be aware of this. I don't
have the Lisp chops to implement what mathematician's generally do
with irrationals which is to ignore the value of the decimal expansion
and deal with it symbolically. I'll have to look into that.

**** Questions 

Again, still considering this as naively as possible.

***** What do the irrational numbers mean physically? 

Obviously any shape that requires an irrational length somewhere in
it's expanse "exists". Even if we define shapes radially, the sides
lengths of the sides become irrational with respect to the
diagonals. I don't think a curvature exists such that I can set a
minimum length as a radius and expect that a circle would be an
integer multiple of it (or, coorespondingly, in any higher dimensional
curvature).

Speculations:

Perhaps there isn't just one fundamental distance, but an infinite
number of them, each with a fundamental duration required to traverse
it. This is more or less what I did when I defined a circumference
as 1.

Perhaps cartesian space at the smallest scale is unstable and the
tiniest volumes have to shift, stretching, squeezing and twisting
themselves until purely integer dimensions remain. I think this is
impossible, so they'll never find one, but constantly strive.

***** What is the oneness of (sqrt 2)?

Words just spew out sometimes. There are some important
differences. =(* 2 (sqrt 2))= is 2. =(* 3 (sqrt 2))= is another
irrational (same as =(expt 4 (/ 3 4))=), so no multiplicative identity
there, one is still one.

**** TODO 4 or more dimensions

I thought it was (z, y, x,...), but now I'm not sure each new axis
doesn't have the effect of pushing itself on to the dimensions list
list (..., z, y, x). I'll have to experiment with this again.

*** Spherical

Spherical velocity vectors may be convenient for this exercise. They
are composed of a radial speed magnitude (which might be easiest to
define with =(distance (c-velocity ...))=) and enough angles to
describe the magnitudes' direction on orthagonal planes.

#+BEGIN_SRC lisp
  (defmethod s-distance ((sv vector))
    "Distance of a spherical velocity vector"
    (first (bases sv)))
  
  (defmethod s-direction ((sv vector))
    "Direction of a spherical velocity vector"
    (rest (bases sv)))
  
  (defun s-velocity-p (sv)
    "Test if argument could be an s-velocity vector."
    (let ((b (bases v)))
      (and (speedp (first b))
           (every (rest b) 'anglep))))
  
  (deftype s-velocity ()
    "Define s-velocity vector"
    `(satisfies s-velocity-p))
  
  (defun s-velocity (&rest args)
    "Create a spherical vector"
    (let ((sv (make-array (length args)
                         :fill-pointer t
                         :initial-contents args)))
      (or (check-type sv s-velocity) sv)))
#+END_SRC

** Code review

*** TODO make sure c-vector and s-vector work as expected

*** TODO bases doesn't check input is a vector
** Questions [/]

** TODO n-sphere, n-ball

*** solid angle of unit n-sphere

I might have translated this wrong.

#+BEGIN_SRC lisp
  (defun n-angle (d)
    (if (evenp d)
        (/ 1 (! (1- (/ d 2))))
        (* (/ (! (/ (1- d) 2))
              (! (1- d)))
           (expt 2 d)
           (expt 1/2 (/ (1- d) 2)))))
#+END_SRC

* TODO Coordinates

Where are we? 

Defining positions. Rehash vectors.

#+BEGIN_SRC lisp
  (defun positionp (p)
    "A position is...")
  
  
  ;; FIXME: this is old
  (defclass position ()
    ((coordinates :reader coords :initarg :coords))
    (:documentation "A sequence of one or more numbers, called coordinates
  The coordinates in the sequence may be of types:
  
  - either integers or ratios (not both mixed)
    + representing coordinates/points in a rectilinear volume.
    + each number is a distance from origin point (0) along orthagonal axes.
    + number of points indicates dimensions of volume (usually 1 <= d <= 3).
  
  - one integer followed by one or more ratios between 0 and 1
    + the integer represents a distance from an origin point.
    + the ratios represent angular coordinates for orthagonal axis planes.
    + the number of values represents the number of dimensions in the volume.
  
  In either case the order in which coordinates map to axes is up to the user."))
  
  (defmethod distance ((p1 vector) (p2 vector))
    "Interval of positions")  
#+END_SRC

* TODO Co-motion

- comparison
- correspondence
- correlation

- velocity ("co-moving")

#+BEGIN_SRC lisp
  (defmethod velocity= ((v1 vector) (v2 vector))
    "Are the two velocities the same?"
    (equalp v1 v2))
#+END_SRC

* TODO Composition

** matter/density

** momentum

* TODO Conservation

** TODO Change

Perhaps this should be the first chapter. I could probably go a long
way just with the ideas of inertia and entropy.

No one likes change, not even physics, where change is resisted from
every quarter.

*** TODO inertia
**** distance/duration
***** displacement
***** accelleration

**** direction
*** TODO entropy
**** disintegration

* TODO Connections
** electromagnetism
** gravitation
** emergence
* TODO Topics
** Momentum
   - http://en.wikipedia.org/wiki/Momentum

** Special Relativity
   - http://en.wikipedia.org/wiki/Special_relativity

#+BEGIN_SRC lisp
  (defun gamma (velocity)
    (/ 1 
       (sqrt
        (- 1 (/ (expt velocity 2)
                (expt +c+ 2))))))
#+END_SRC

** Basis
   - http://en.wikipedia.org/wiki/Basis_(linear_algebra)
** Rapidity
   - http://en.wikipedia.org/wiki/Rapidity
   - http://en.wikipedia.org/wiki/Velocity-addition_formula
** Coordinate systems
   - http://en.wikipedia.org/wiki/Coordinate_system
   - http://en.wikipedia.org/wiki/Cartesian_coordinate_system
   - http://en.wikipedia.org/wiki/Polar_coordinate_system
   - http://en.wikipedia.org/wiki/Spherical_coordinate_system
   - http://en.wikipedia.org/wiki/Curvilinear_coordinates
   - http://en.wikipedia.org/wiki/Homogeneous_coordinates
** Higher dimensions
   - http://en.wikipedia.org/wiki/N-sphere
   - http://en.wikipedia.org/wiki/Hypercube
** Space
   - http://en.wikipedia.org/wiki/Affine_space
   - http://en.wikipedia.org/wiki/Position_(vector)
   - http://en.wikipedia.org/wiki/Hyperbolic_space
   - http://en.wikipedia.org/wiki/Minkowski_space
   - http://en.wikipedia.org/wiki/Distance
   - http://en.wikipedia.org/wiki/Norm_(mathematics)
** Constants
   - http://en.wikipedia.org/wiki/Physical_constant
   - http://en.wikipedia.org/wiki/Natural_units
   - http://en.wikipedia.org/wiki/Planck_units
   - http://www.tauday.com/tau-manifesto

*** ideals objects
- black body :: absorbs all electromagnetic radiation. The spectrum of
                radiation emitted is proportional to it's temperature.
- ideal gas ::
- free space (vacuum) ::
*** greek letters

| name    | small | large | use                                           |
|---------+-------+-------+-----------------------------------------------|
| pi      | π     |       | ratio of a circle's circumference to diameter |
| omega   | ω     |       | angular frequency (radians/time)              |
| nu      | ν     |       | linear frequency (length/time)                |
| lambda  | λ     |       | wavelength                                    |
| rho     | ρ     |       | momentum (mass * velocity)                    |
| epsilon | ε     |       | electric permittivity                         |
| epsilon | Ε     |       | energy                                        |
| theta   |       | Θ     | temperature                                   |
| mu      | μ     |       | magnetic permeability                         |
| alpha   | α     |       | fine structure constant                       |
| phi     | φ     |       | phase constant of wave                        |
| psi     | ψ     |       | wave function                                 |
| alpha   |       | Α     | amplitude                                     |
| tau     |       | Τ     | period or time                                |
| tau     | τ     |       | ratio of a circle's circumference to radius   |
| kappa   | κ     |       | wave number circular                          |
| sigma   | σ     |       | wave number linear                            |

*** roman letters

| small | large | use                         |
|-------+-------+-----------------------------|
| c     |       | speed of light in a vaccuum |
|       | G     | gravitational constant      |
| e     |       | elementary charge constant  |
| q     |       | alternate name for e        |
|       | E     | energy                      |
|       | T     | time                        |
|       | S     | entropy                     |
|       |       |                             |

*** waves

- T :: period (time)
- Α :: amplitude (distance between the equilibrium and the height of disturbance)
- λ :: wavelength (distance between to crests or troughs)
- φ :: phase constant
- ν :: frequency linear
- ω :: frequency circular (angular)
- σ :: wavenumber linear
- κ :: wavenumber circular

T =  1/ν
ν =  1/T
σ =  1/λ

ω = 2π/T = 2πν
λ = 2π/κ
κ = 2π/λ


*** Planck units

**** Plank constants

- E :: energy of a charged particle in a black-body
- ν :: frequency of electromagnetic radiation emitted by particle
- ℎ :: the proportion of ν/E

E = νℎ
ν = E/ℎ
ℎ = E/ν


- c :: speed of light in a vacuum
- ν :: frequency of light
- λ :: wavelength

c = νλ


Thus:

E = νℎ/λ

- ρ :: linear momentum
- λ :: quantum wavelength (de Broglie)
- ℎ :: proportion

λ = ℎ/ρ
ℎ = ρλ
ρ = λ/ℎ

When:

- E :: energy
- ω :: angular frequency (2πν) (radians/T)
- ℏ :: ℎ/2π

E = ωℏ

- 

| symbol | constant      |
|--------+---------------|
| ℎ      | ν/E or ρ/λ    |
| ℏ      | ω/E or ρ/2πλ  |
| ke     | 1/(4πε₀)      |
| ε₀     | 1/(μ₀c²)      |
| μ₀     |               |

- μ₀ :: magnetic permeability in vacuum
- ε₀ :: electric permittivity in vaccum
- c₀ :: speed of light in a vacuum

ε₀ = 1/(c₀c₀μ₀)
c₀ = 1/sqrt(μ₀ε₀)

- α :: fine structure constant
- ke :: electric force constant (Coulomb)
- e :: elementary charge constant
- c :: speed of light in a vacuum
- ℏ :: (reduced Plank constant)

ε₀ = 1/(4π * ke)
e² = 2ℎα/μ₀c = 2ℎαε₀c


- F :: electrical force
- ke :: electric force constant (Coulomb)
- q :: point charge
- r :: distance between charges q1 and q2

F = ke * ((q1 * q2)/r^2)

- R :: gas constant
- P :: pressure (force/area)
- V :: volume
- n :: amount
- T :: temperature

R = PV/nT

- F :: force 
- A :: area
- L :: length

R = (F/A * V)/nT
R = (F/L^2 * L^3)/nT
R = FL/nT

- W = Work (F * L)

R = W/nT

- kb :: energy/temperature (Boltzmann)
- Na :: particles/mol constant (Avogadro)

kb = R/Na

**** fundamental units
| Planck Unit | Symbol | Relation to other constants                             |
|-------------+--------+---------------------------------------------------------|
| Length      | L      | =(sqrt (/ (* hbar G) (expt c 3)))=                      |
| Time        | T      | =(sqrt (/ (* hbar G) (expt c 5)))=                      |
| Mass        | M      | =(sqrt (/ (* hbar c) G))=                               |
| Charge      | Q      | =(sqrt (* 4 pi epsilon-sub-zero hbar c))=               |
| Temperature | Θ      | =(sqrt (/ (* hbar (expt c 5)) (* G (expt k-sub-b 2))))= |


Traditionally:

- G :: gravitational constant
- c :: speed of light in a vaccum
- ke :: electric force constant (Coulomb's constant)
- kb :: energy/temperature constant (Boltzmann's constant)
- ℏ :: angular frequency/energy constant ("h-bar" or reduced Planck
       constant)

Funny note about h-bar and h

h relates energy to frequency of light (simplification)
h-bar relates energy to angular frequency (radians vs hertz)

h-bar is h/2pi. If hbar = 1 then h = 2pi. if 2pi = 1 then h = hbar. I
have no idea what this implies, if anything.

**** Normalized constants

| Normalized Constants       | Symbol | Value | Units                       |
|----------------------------+--------+-------+-----------------------------|
| speed of light in a vacuum | c      |     1 | =(/ L T)=                   |
| gravitation                | G      |     1 | =(/ (* L L L) (* M T T))=   |
| angular frequency/energy   | ℏ      |     1 | =(/ (* M L L) T)=           |
| electric force             | ke     |     1 | =(/ (* M L L) (* Q Q T T))= |
| energy/temperature         | kb     |     1 | =(/ (* M L L) (* Θ T T))=   |

**** Derived

| name                | dimension                 | expression                         |
|---------------------+---------------------------+------------------------------------|
| frequency (angular) | =(/ 1 T)=                 |                                    |
| area                | =(* L L)=                 |                                    |
| volume              | =(* L L L)=               |                                    |
| density (mass)      | =(/ M (* L L L))=         |                                    |
| density (energy)    | =(/ M (* L T T))=         |                                    |
| pressure            | =(/ M (* L T T))=         |                                    |
| momentum            | =(/ (* M L)          T)=  | =(/ (* hbar G) (expt c 3))=        |
| force               | =(/ (* M L)   (*   T T))= | =(/ (expt c 4) G)=                 |
| energy              | =(/ (* M L L) (*   T T))= | =(sqrt (/ (* hbar (expt c 5)) G))= |
| power               | =(/ (* M L L) (* T T T))= |                                    |
| intensity           | =(/ M         (* T T T))= |                                    |
|---------------------+---------------------------+------------------------------------|
| current             | =(/ Q T)=                 |                                    |
| voltage             | =(/ (* M L L) (* Q T T))= |                                    |
| impedance           | =(/ (* M L L) (* Q Q T))= |                                    |


**** Other constants
| Other Constants                       | Symbol |      Value | Units |
|---------------------------------------+--------+------------+-------|
| electrical permittivity of free space | ε₀     |            |       |
| ratio of circumference to diameter    | π      | 3.14159... |       |
| elementary charge                     | e      |            |       |


**** TODO integrate when ready

from http://en.wikipedia.org/wiki/Planck_units#Simplification_of_physical_equations

****** gravitation
#+BEGIN_SRC lisp
  ;;; With G = 1
  
  (defun gravitation (m1 m1 d)
    (- (/ (* m1 m2) (* d d))))
#+END_SRC

#+BEGIN_QUOTE
In order for this last equation to be valid (without G present), F, m1, m2, and r are understood to be the dimensionless numerical values of these quantities measured in terms of Planck units. This is why Planck units or any other use of natural units should be employed with care; referring to G = c = 1, Paul S. Wesson wrote that, "Mathematically it is an acceptable trick which saves labour. Physically it represents a loss of information and can lead to confusion."
#+END_QUOTE

****** Einstein's field equation

#+BEGIN_SRC lisp
  ;; with G = c = 2pi = 1
  
  (defun G-tensor (stress-energy-tensor)
    (* 4 stress-energy-tensor))
#+END_SRC

****** Mass energy equivalence

#+BEGIN_SRC lisp
  ;;; with c = 1 thus E = m
  
  (defclass matter-energy ()
    ((me :reader mass :reader energy :initarg :me)))
#+END_SRC

****** Energy momentum relation

#+BEGIN_SRC lisp
  ;; with c = 1 otherwise we'd have (* m m c c c c) and (* p p c c)
  
  (defmethod energy ((m mass) (p momentum))
    (sqrt (+ (* m m) (* p p))))
#+END_SRC

****** Thermal energy per particle per degree of freedom

with kb = 1, else ~(= E (/ (* kb T) 2))~

#+BEGIN_SRC lisp
  (defmethod energy ((t absolute-temperature))
    (/ t 2))
#+END_SRC

****** Boltzmann's entropy formula

S = kb * ln * omega
kb - Boltzmann's constant
omega - number of microstates consistent with macrostate

with kb = 1

#+BEGIN_SRC lisp
  (defun entropy (omega)
    (log omega))
#+END_SRC

****** Planck's law

Surface intensity per unit solid angle per unit angular frequency
for black body at temperature T.

with:

- I :: intensity
- w :: frequency (small omega)
- T :: absolute temperature
- h-bar :: energy/angular frequency constant = 1
- 2pi :: circle constant = 1
- e :: ? probably Napier constant

#+BEGIN_SRC lisp
  (defun intensity (w T)
    (* (/ (* w w) 8) (/ 1 (1- (expt e (/ w T))))))
#+END_SRC

****** Stefan-Boltzmann constant
#+BEGIN_QUOTE
"The total intensity radiated over all wavelengths increases
as the temperature increases", of a black body which is proportional
to the fourth power of the thermodynamic temperature.
#+END_QUOTE

- sigma :: =(/ (* pi pi kb kb kb kb) (* 60 hbar hbar hbar c c))=
- kb :: Boltzmann constant
- hbar :: reduced Planck constant
- c :: speed of light in a vacuum

#+BEGIN_SRC lisp
  (defconstant sigma
    (/ (* pi pi) 60)
    "Stefan-Boltzmann constant.
  
  Black body radiation intensity to temperature")
#+END_SRC

****** TODO Bekenstein–Hawking black hole entropy

****** TODO Schrödinger's equation

****** TODO Hamiltonian form of Schrödinger's equation

****** TODO Covariant form of the Dirac equation

****** TODO Maxwell's equations
****** TODO Black hole features

Once stable, black holes are believed to retain just 3 features:

- Q :: Electric charge
- J :: Angular momentum
- M :: Mass

~(<= (* M M) (+ (* Q Q) (* J/M J/M)))~

Black hole radius (Schwartzchild, 1916)

~r = 2GM/c^2~ 

#+BEGIN_SRC lisp
  (defmethod radius ((bh black-hole))
    (with-accessors ((m mass)
                     (q electric-charge)
                     (j angular-momentum)) bh
      (cond ((< 0 q j)
             ;; Kerr-Newman
             )
            ((and (zerop q) (< 0 j))
             ;; Kerr
             )
            ((and (< 0 q) (zerop j))
             ;; Reissner-Nordstrom
             
             )
            ((= 0 q j)
             ;; Schwartzchild
             (* 2 m)))))
  
#+END_SRC

** Complements
  - http://en.wikipedia.org/wiki/Complementarity_(physics)
  - position and momentum
  - wave and particle
  - 
** COMMENT Naming things is hard
*** vocabulary


- TODO This could be adapted for Lexicode

- time
- mass
- axis/es
- span

- basis/es (vector)
- point
- event
- speed
- range
- frame
- space
- field

- length
- volume
- affine
- origin
- source
- vertex
- matrix
- vector
- scalar
- matter
- extent/d

- bearing
- heading

- duration
- displace
- distance
- position
- rapidity
- velocity
- location
- interval

- direction
- dimension
- magnitude
- reference
- spherical

- coordinate

- orientation
- rectilinear
- cylindrical

*** vernacular

It might be useful to come with names of these generic measures
independant of a formal system of units.

- speck :: length
- tick :: time
- zap :: electrical charge
- dizz :: angular momentum
- heft :: mass-energy

Eh, that's just being cute.

* References
- http://hyperphysics.phy-astr.gsu.edu/hbase/hph.html
  + http://hyperphysics.phy-astr.gsu.edu/hbase/relativ/relcon.html#relcon
